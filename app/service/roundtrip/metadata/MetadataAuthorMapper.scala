package service.roundtrip.metadata

import com.github.tototoshi.csv.CSVReader
import service.roundtrip.model.AuthorDocument
import util.StringUtils.notEmpty

import javax.inject.Inject
import scala.collection.concurrent.TrieMap

/**
  * This class is using <b>author-mapping.csv</b> document, generated by [[service.authormapper.AuthorMapperService]],
  * to map given SWS document identifier to author document in PublishOne
  */
class MetadataAuthorMapper @Inject()() {

  private lazy val swsAuthorIdIndex: Int = 0
  private lazy val p1AuthorDocIdIndex: Int = 12
  private lazy val p1AuthorDocNameIndex: Int = 13
  private lazy val p1AuthorListItemIdIndex: Int = 14
  private lazy val authorDocumentMappingCache: TrieMap[String, AuthorDocument] = new TrieMap[String, AuthorDocument]()

  def mapAuthorToDocument(swsAuthorId: String): Option[AuthorDocument] = authorDocumentMappingCache.get(swsAuthorId)

  def initCache(): Unit = {
    cleanCache()
    val csv = CSVReader.open("author-mapping.csv")
    csv.toStream.tail.foreach { row =>
      val swsAuthorId = row(swsAuthorIdIndex)
      val p1AuthorDocId = row(p1AuthorDocIdIndex)
      val p1AuthorDocName = row(p1AuthorDocNameIndex)
      val p1AuthorListItemId = if (row.size > p1AuthorListItemIdIndex) row(p1AuthorListItemIdIndex) else ""
      if (notEmpty(p1AuthorDocId) && notEmpty(p1AuthorDocName))
        authorDocumentMappingCache.put(swsAuthorId, AuthorDocument(p1AuthorDocId.toInt, p1AuthorDocName, p1AuthorListItemId))
    }
  }

  def cleanCache(): Unit = authorDocumentMappingCache.clear()

}
