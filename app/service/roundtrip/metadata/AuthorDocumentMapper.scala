package service.roundtrip.metadata

import com.github.tototoshi.csv.CSVReader
import service.roundtrip.model.AuthorDocumentMapping
import util.ConfigUtils
import util.StringUtils.notEmpty

import javax.inject.{Inject, Singleton}
import scala.collection.concurrent.TrieMap
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future

/**
  * This class is using <b>author-mapping.csv</b> document, generated by [[service.authormapper.AuthorMapperService]],
  * to map given SWS document identifier to author document in PublishOne
  */
@Singleton
class AuthorDocumentMapper @Inject()(configUtils: ConfigUtils) {

  private lazy val swsAuthorIdIndex: Int = 0
  private lazy val p1AuthorDocIdIndex: Int = 13
  private lazy val p1AuthorDocNameIndex: Int = 14
  private lazy val p1AuthorItemIdIndex: Int = 12
  protected[metadata] lazy val authorDocumentMappingCache: TrieMap[String, AuthorDocumentMapping] = new TrieMap[String, AuthorDocumentMapping]()

  def initCache: Future[Unit] = Future {
    val csv = CSVReader.open(configUtils.publishOneAuthorMappingFile)
    csv.toStream.tail.foreach { row =>
      val swsAuthorId = row(swsAuthorIdIndex)
      val p1AuthorDocId = if (row.size > p1AuthorDocIdIndex) row(p1AuthorDocIdIndex) else ""
      val p1AuthorDocName = if (row.size > p1AuthorDocNameIndex) row(p1AuthorDocNameIndex) else ""
      val p1AuthorItemId = if (row.size > p1AuthorItemIdIndex) row(p1AuthorItemIdIndex) else ""
      if (notEmpty(p1AuthorDocId))
        authorDocumentMappingCache.put(swsAuthorId, AuthorDocumentMapping(p1AuthorDocId.toInt, p1AuthorDocName, p1AuthorItemId))
    }
  }

  def cleanCache(): Unit = authorDocumentMappingCache.clear()

  def mapAuthorToDocument(swsAuthorId: String): Option[AuthorDocumentMapping] = authorDocumentMappingCache.get(swsAuthorId)

}
